## Teoria das √Årvores

### √Årvores Bin√°rias

Defini√ß√£o:
√Årvores bin√°rias de pesquisa que s√£o projetadas para um acesso r√°pido √† informa√ß√£o. Idealmente a √°rvore deve ser razoavelmente equilibrada e a sua altura ser√° dada (no caso de estar completa) por h=log2 (n+1) O tempo de pesquisa tende a O(log2N) Por√©m, com sucessivas inser√ß√µes de dados principalmente ordenados, ela pode se degenerar para O(n).

√Årvores Completas:
S√£o aquelas que minimizam o n√∫mero de compara√ß√µes efetuadas no pior caso para uma busca com chaves de probabilidades de ocorr√™ncias id√™nticas.
Inser√ß√£o de elementos em uma √°rvore bin√°ria de busca
‚Ä¢ O primeiro elemento inserido assumir√° o papel de raiz da √°rvore;
‚Ä¢ Todo novo elemento entrar√° na √°rvore como uma folha;
‚Ä¢ Se o elemento for menor ou igual √† raiz ser√° inserido no ramo da esquerda. Caso contr√°rio, no ramo da direita (para √°rvores decrescentes inverte-se a regra).
Remo√ß√£o de elementos em uma √°rvore bin√°ria de busca
Considerando que podemos remover qualquer elemento de uma √°rvore, podem ocorrer as seguintes situa√ß√µes:

1. O Elemento a ser removido √© um n√≥ folha (sem filhos √† esquerda e √† direita);
2. O Elemento a ser removido possui apenas um filho (√† direita ou √† esquerda);
3. O Elemento a ser removido possui dois filhos.
Travessia da √°rvore:
pr√©-ordem  (os filhos de um n√≥ s√£o processados ap√≥s o n√≥)
Cima para baixo
p√≥s-ordem  (os filhos s√£o processados antes do n√≥)
Baixo para cima
em-ordem , em que se processa o filho √† esquerda, o n√≥, e finalmente o filho √† direita.

M√©todos de Balanceamento  
H√° duas categorias: din√¢mico e global (ou est√°tico).  
O rebalanceamento din√¢mico mant√©m a √°rvore balanceada toda vez que um n√≥ √© inserido ou removido.  AVL √© o melhor exemplo  
O global permite a √°rvore crescer sem limites e somente faz o balanceamento quando tal necessidade √© acionada, externamente.
Existe alguma raz√£o para evitarmos algoritmos de busca em √°rvore recursivos (mem√≥ria, complexidade, etc)? Justifique.
Sim, pois quando essa busca acontece no pior dos casos, ou seja, a √°rvore √© degenerada, a busca ir√° percorrer todos os n√≥s de um lado, apenas para depois desempilhar os valores na pilha de recurs√£o e retornar nulo quando chegar na raiz, caso n√£o encontre o valor. Isso faz com que a complexidade do algoritmo aumente, sendo ele O(logn), consequentemente aumentando seu tempo de execu√ß√£o.
E ainda existem outras formas de busca, como a busca iterativa, que tamb√©m possui loops mas que n√£o utilizam recurs√£o, e sim repeti√ß√£o, resultando numa complexidade e tempo de execu√ß√£o menores.



AVL

Caracter√≠sticas: 
√â uma √°rvore altamente balanceada, isto √©, nas inser√ß√µes e exclus√µes, procura-se executar uma rotina de balanceamento tal que as alturas das sub-√°rvores esquerda e sub-√°rvores direita tenham alturas bem pr√≥ximas
Idealmente a √°rvore deve ser razoavelmente equilibrada e a sua altura ser√° dada (no caso de estar completa) por - h=log2(n+1)
A √°rvore AVL tem complexidade O(log n) para todas opera√ß√µes e ocupa espa√ßo n, onde n √© o n√∫mero de n√≥s da √°rvore.




Defini√ß√£o: Uma √°rvore AVL √© uma √°rvore na qual as alturas das sub√°rvores esquerda e direita de cada n√≥ diferem no m√°ximo por uma unidade.

Como ocorre a Busca
A busca √© a mesma utilizada em √°rvore bin√°ria de busca.
A busca pela chave de valor K inicia sempre pelo n√≥ raiz da √°rvore.
Seja pt_u um ponteiro para o n√≥ u sendo verificado. Caso o pt_u seja nulo ent√£o a busca n√£o foi bem sucedida (K n√£o est√° na √°rvore ou √°rvore vazia). Verificar se a chave K igual pt_u->chave (valor chave armazenado no n√≥ u), ent√£o a busca foi bem sucedida. Caso contr√°rio, se K < pt_u->chave ent√£o a busca segue pela sub√°rvore esquerda; caso contr√°rio, a busca segue pela sub√°rvore direita.

Exemplo de algoritmo de busca em Java.
// O m√©todo de procura numa AVL √© semelhante ao busca bin√°ria de uma √°rvore bin√°ria de busca comum.
public BSTNode<T> search(T element) {
    return search(element, this.root);
}

// M√©todo auxiliar √† recurs√£o.
private BSTNode<T> search(T element, BSTNode<T> node) {
    if (element == null || node.isEmpty()) {
        return new BSTNode<T>();
    }
    
    if (node.isEmpty() || node.getData().equals(element)) {
        return node;
    } else if (node.getData().compareTo(element) > 0) {
        return search(element, node.getLeft());
    } else {
        return search(element, node.getRight());
    }
}

Inser√ß√£o
Para inserir um novo n√≥ de valor K em uma √°rvore AVL √© necess√°ria uma busca por K nesta mesma √°rvore. Ap√≥s a busca, o local correto para a inser√ß√£o do n√≥ K ser√° em uma sub√°rvore vazia de uma folha da √°rvore. Depois de inserido o n√≥, a altura do n√≥ pai e de todos os n√≥s acima deve ser atualizada. Em seguida o algoritmo de rota√ß√£o simples ou dupla deve ser acionado para o primeiro n√≥ pai desregulado. 
Os par√¢metros p e mudou_h s√£o passados por refer√™ncia. O ponteiro p aponta para o n√≥ atual. O par√¢metro mudou_h √© do tipo l√≥gico e informa ao chamador se a sub√°rvore apontada por p mudou sua altura.

Como identificar mudan√ßa de altura?
Considerar que o n√≥ p √© raiz da sub√°rvore Tp e houve inser√ß√£o em uma de suas sub√°rvores.
Caso a sub√°rvore Tp tenha mudado de altura, decrementar fb (inser√ß√£o na sub√°rvore esquerda) ou incrementar fb (inser√ß√£o na sub√°rvore direita).
Caso 1: Ao inserir um n√≥ folha, a sub√°rvore Tp passa de altura 0 para altura 1, ent√£o Tp mudou de altura.
Caso 2: fb=0 antes da inser√ß√£o foi alterado para 1 ou -1, ent√£o a sub√°rvore Tp mudou de altura.
Caso 3: fb=1 ou -1 antes da inser√ß√£o, passou a ter valor 0, ent√£o a sub√°rvore Tp n√£o mudou de altura.
Caso 4: O fb passou a ter valor -2 ou 2 ap√≥s a inser√ß√£o, ent√£o h√° necessidade de aplica√ß√£o de alguma opera√ß√£o de rota√ß√£o. Ap√≥s a rota√ß√£o, a sub√°rvore Tp ter√° a mesma altura anterior √† inser√ß√£o.
Exemplo de algoritmo de inser√ß√£o em Java
/* Por defini√ß√£o, a √°rvore AVL √© uma √°rvore bin√°ria de busca (BST).
*  Por este motivo utiliza-se aqui a mesma defini√ß√£o (classe) de N√≥s que uma BST simples.
*/
public void insert(T element) {
    insertAux(element);
    BSTNode<T> node = search(element); // Pode-se utilizar o mesmo search exemplificado acima.
    rebalanceUp(node);
}

private void insertAux(T element) {
    if (element == null) return;
    insert(element, this.root);
}

private void insert(T element, BSTNode<T> node) {
    if (node.isEmpty()) {
        node.setData(element);
        node.setLeft(new BSTNode<T>());
        node.setRight(new BSTNode<T>());
        node.getLeft().setParent(node);
        node.getRight().setParent(node);
    } else {
        if (node.getData().compareTo(element) < 0) {
            insert(element, node.getRight());
        } else if (node.getData().compareTo(element) > 0) {
            insert(element, node.getLeft());
        }
    }
}


Algoritmos de complemento √† inser√ß√£o e/ou algoritmos para identificar desbalanceamento em Java
protected void rebalanceUp(BSTNode<T> node) {
    if (node == null || node.isEmpty()) return;
    rebalance(node);
    if (node.getParent() != null) {
        rebalanceUp(node.getParent());
    }
}

protected int calculateBalance(BSTNode<T> node) {
    if (node == null || node.isEmpty()) return 0;
    return height(node.getRight()) - height(node.getLeft()); 
}

protected void rebalance(BSTNode<T> node) {
    int balanceOfNode = calculateBalance(node);
    
    if (balanceOfNode < -1) {
        if (calculateBalance(node.getLeft()) > 0) {
            leftRotation(node.getLeft());
        }
        rightRotation(node);
    } else if (balanceOfNode > 1) {
        if (calculateBalance(node.getRight()) < 0) {
            rightRotation(node.getRight());
        }
        leftRotation(node);
    }
}


Rota√ß√£o para Direita e para Esquerda em Java
protected void leftRotation(BSTNode<T> no) {
	BTNode<T> noDireito = no.getRight();

	no.setRight(noDireito.getLeft());

	noDireito.getLeft().setParent(no);
	noDireito.setLeft(no);
	noDireito.setParent(no.getParent());
	no.setParent(noDireito);

	if (no != this.getRoot()) {
		if (noDireito.getParent().getLeft() == no) {
			noDireito.getParent().setLeft(noDireito);
		} else {
			noDireito.getParent().setRight(noDireito);
		}
	} else {
			this.root = (BSTNode<T>) noDireito;
	}
}

protected void rightRotation(BSTNode<T> no) {
	BTNode<T> noEsquerdo = no.getLeft();

	no.setLeft(noEsquerdo.getRight());

	noEsquerdo.getRight().setParent(no);
	noEsquerdo.setRight(no);
	noEsquerdo.setParent(no.getParent());
	no.setParent(noEsquerdo);

	if (no != this.getRoot()) {
		if (noEsquerdo.getParent().getLeft() == no) {
			noEsquerdo.getParent().setLeft(noEsquerdo);
		} else {
			noEsquerdo.getParent().setRight(noEsquerdo);
		}
	} else {
		this.root = (BSTNode<T>) noEsquerdo;
	}
}




Remo√ß√£o
O primeiro passo para remover uma chave K consiste em realizar uma busca bin√°ria a partir do n√≥ raiz. Caso a busca encerre em uma sub√°rvore vazia, ent√£o a chave n√£o est√° na √°rvore e a remo√ß√£o n√£o pode ser realizada. Caso a busca encerre em um n√≥ u o n√≥ que contenha a chave ent√£o a remo√ß√£o poder√° ser realizada da seguinte forma:
Caso 1: O n√≥ u √© uma folha da √°rvore, apenas exclui-lo.
Caso 2: O n√≥ u tem apenas uma sub√°rvore, necessariamente composta de um n√≥ folha, basta apontar o n√≥ pai de u para a √∫nica sub√°rvore e excluir o n√≥ u.
Caso 3: O n√≥ u tem duas sub√°rvores: localizar o n√≥ v predecessor ou sucessor de K, que sempre ser√° um n√≥ folha ou possuir√° apenas uma sub√°rvore; copiar a chave de v para o n√≥ u; excluir o n√≥ v a partir da respectiva sub√°rvore de u.
O √∫ltimo passo consiste em verificar a desregulagem de todos n√≥s a partir do pai do n√≥ exclu√≠do at√© o n√≥ raiz da √°rvore. Aplicar rota√ß√£o simples ou dupla em cada n√≥ desregulado.
Exemplo de algoritmo de remo√ß√£o em Java
public void remover(int valor) {
		removerAVL(this.raiz, valor);
	}

	private void removerAVL(No atual, int valor) {
		if (atual != null) {

			if (atual.getChave() > valor) {
				removerAVL(atual.getEsquerda(), valor);

			} else if (atual.getChave() < valor) {
				removerAVL(atual.getDireita(), valor);

			} else if (atual.getChave() == valor) {
				removerNoEncontrado(atual);
			}
		}
	}

	private void removerNoEncontrado(No noARemover) {
		No no;

		if (noARemover.getEsquerda() == null || noARemover.getDireita() == null) {

			if (noARemover.getPai() == null) {
				this.raiz = null;
				noARemover = null;
				return;
			}
			no = noARemover;

		} else {
			no = sucessor(noARemover);
			noARemover.setChave(no.getChave());
		}

		No no2;
		if (no.getEsquerda() != null) {
			no2 = no.getEsquerda();
		} else {
			no2 = no.getDireita();
		}

		if (no2 != null) {
			no2.setPai(no.getPai());
		}

		if (no.getPai() == null) {
			this.raiz = no2;
		} else {
			if (no == no.getPai().getEsquerda()) {
				no.getPai().setEsquerda(no2);
			} else {
				no.getPai().setDireita(no2);
			}
			verificarBalanceamento(no.getPai());
		}
		no = null;
	}

Balanceamento: hd ‚Äì he —î {0, 1, -1}



Se o fator de balanceamento de qualquer n√≥ ficar menor do que -1 ou maior do que 1 ent√£o a √°rvore tem que ser balanceada.












Rota√ß√µes em AVL
Nas √°rvores AVL, ap√≥s cada opera√ß√£o, como inser√ß√£o e exclus√£o, o fator de balanceamento de cada n√≥ precisa ser verificado. Se cada n√≥ satisfizer a condi√ß√£o do fator de balanceamento, a opera√ß√£o pode ser conclu√≠da. Caso contr√°rio, a √°rvore precisa ser rebalanceada utilizando as opera√ß√µes de rota√ß√£o. Existem quatro rota√ß√µes e elas s√£o classificadas em dois tipos.
Rota√ß√£o simples √† esquerda (rota√ß√£o SE - RR)
Na rota√ß√£o simples √† esquerda, cada n√≥ se move uma posi√ß√£o para a direita da posi√ß√£o atual.



Rota√ß√£o simples √† direita (rota√ß√£o SD - LL)
Na rota√ß√£o simples √† direita, cada n√≥ se move uma posi√ß√£o para a direita da posi√ß√£o atual.



Rota√ß√£o dupla √† direita (rota√ß√£o DD)
As rota√ß√µes duplas √† direita s√£o uma combina√ß√£o de uma √∫nica rota√ß√£o para a esquerda seguida de uma rota√ß√£o para a direita. 
Primeiro, cada n√≥ se move uma posi√ß√£o para a esquerda. Depois, se move uma posi√ß√£o para a direita da posi√ß√£o atual. 
Rota√ß√£o dupla √† esquerda (rota√ß√£o DE)
As rota√ß√µes duplas √† esquerda s√£o uma combina√ß√£o de uma √∫nica rota√ß√£o para a direita seguida de uma rota√ß√£o para a esquerda. Primeiro, cada n√≥ se move uma posi√ß√£o para a direita. Depois, se move uma posi√ß√£o para a esquerda da posi√ß√£o atual.
OBS: As opera√ß√µes de rota√ß√£o possuem tempo constante, j√° que a √∫nica coisa que acontece nessas a√ß√µes √© a mudan√ßa de alguns ponteiros. Assim como as rota√ß√µes, recuperar o fator de balanceamento e atualizar a altura tamb√©m possuem tempo constante. Dessa forma, a complexidade de inser√ß√£o em uma AVL continua sendo O(h), em que h √© a altura da √°rvore, tal qual em uma √°rvore bin√°ria de busca. Mas, como a AVL √© balanceada, a altura da √°rvore √© O(Log n), sendo tamb√©m a complexidade de inser√ß√£o de n√≥ nesse tipo de √°rvore.
√Årvore B

Defini√ß√£o: 
√Årvore B √© uma estrutura que, ao inv√©s de armazenar chaves em n√≥s individuais, utiliza um bloco de chaves, chamado p√°gina, para armazenar v√°rios valores. Cada n√≥ de uma √°rvore B √© uma p√°gina.
Muito utilizada para armazenamento e recupera√ß√£o de dados. Ao contr√°rio da AB, pode ter mais do que dois filhos

Caracter√≠sticas: 
√Årvores B possuem ponteiros que apontam para os m√∫ltiplos caminhos e possui auto-balanceamento. Ela costuma n√£o ter uma altura t√£o grande comparada √† outras √°rvores, pelo fato de armazenar blocos de chaves (as p√°ginas). 

OBS: existem dois conceitos para  determina√ß√£o do n√∫mero de ordem de uma √°rvore, O conceito de Rudolf Bayer e Edward McCreight, 1972, criadores da √°rvore B, constata que a ordem de uma √°rvore √© a metade da capacidade de chaves que sua p√°gina pode armazenar. Dessa forma, sendo uma √°rvore com ordem 3, suas p√°ginas podem armazenar entre 3 e 6 chaves.
J√° o conceito de Donald Knuth, 1978, constata que a ordem uma √°rvore B √© a quantidade m√°xima de filhos que uma p√°gina da √°rvore pode ter, e que cada p√°gina cont√©m, sendo d a ordem dessa √°rvore, entre (2d - 1 / 3) e d - 1 chaves. Ent√£o, sendo uma √°rvore com ordem 5, suas p√°ginas podem armazenar entre 2 e 4 chaves, e pode ter no m√°ximo 5 filhos. Esta varia√ß√£o de Knuth √© chamada de √Årvore B*.


Cada √°rvore B possui uma ordem, que determina as caracter√≠sticas dela.  Uma √Årvore B de ordem d deve ter as seguintes propriedades:
a raiz da √°rvore OU √© uma folha, ou seja, √© o √∫nico n√≥ da √°rvore, OU possui no m√≠nimo 2 filhos;
cada n√≥ interno possui no m√≠nimo d + 1 filhos;
cada n√≥ possui no m√°ximo 2d + 1 filhos;
as chaves das p√°ginas devem ser ordenadas do menor para o maior;
cada p√°gina possui entre d e 2d chaves, exceto o n√≥ raiz, que possui entre 1 e 2d chaves;
a quantidade de ponteiros de uma p√°gina √© a quantidade de chaves + 1.
folhas est√£o sempre no mesmo n√≠vel;





Podem ter n chaves por n√≥ (Filhos) ‚Üí Ordem m
Arruma a estrutura em forma serial na mem√≥ria secund√°ria
Usada para implementar BD
Complexidade no pior caso : 
Os valores dos n√≥s ficam junto com as chaves
As buscas s√£o feitas carregando apenas algumas partes por vez, para poupar mem√≥ria
S√£o perfeitamente balanceadas -> Sempre que add um valor, reorganiza aquele n√≥ com base na ordem
A altura m√≠nima de uma √°rvore B com n n√∫mero de n√≥s e m n√∫mero m√°ximo de filhos que um n√≥ n√£o-raiz pode ter √©:

A altura m√°xima de uma √°rvore B com n n√∫mero de n√≥s e t n√∫mero m√≠nimo de filhos que um n√≥ pode ter √©:

Usos e Vantagens
Em algumas aplica√ß√µes, a quantidade de n√≥s √© grande demais para serem armazenadas somente em mem√≥ria, ent√£o √© necess√°rio o uso de mem√≥ria secund√°ria. Isso causa um grande gasto de tempo para acesso a um s√≥ n√≥ de dados. Ent√£o √© usada a √Årvore B, que tem mais de uma chave por n√≥. Ela √© usada para busca eficiente para dados armazenados em mem√≥ria secund√°ria (disco r√≠gido).
√Årvores B s√£o usadas em:
sistemas de arquivos do Windows, Mac e Linux
bancos de dados como ORACLE, Db2, SQL, PostgreSQL, INGRES 
servidores tamb√©m utilizam a abordagem de √°rvore B
utilizado em sistemas CAD (computer-aided design)




Vantagens
Altura menor comparada a outras √°rvores;
Ideais para uso como √≠ndice de arquivo em disco;
Como √© uma √°rvore baixa, s√£o necess√°rios poucos acessos em disco at√© chegar ao ponteiro para o bloco que cont√©m o registro necess√°rio;
indexa√ß√£o multin√≠vel;

Desvantagens
S√£o baseadas em estruturas de dados baseados em disco, e tem alto uso dele;
Um pouco lenta comparada com outras √°rvores, n√£o √© a melhor escolha em todos os casos;

Complexidade

üí° Quanto mais chaves em um n√≥, menos n√≠veis a √°rvore tem e mais otimizada a busca √©
üí° Os galhos que os n√≥s podem ter, tendo por ex 3 ou 4 em um n√≥ s√≥ ligado a valores diferentes se entende por:
Dois galhos que saem de um valor x : Um vai para n√≥s com valores menores que x e outro entre x e y
Um galho que sai de y (que est√° ao lado de x) : Pode ir para um valor maior que y
Ou seja, os v√°rios links que saem de cada valor est√£o diretamente relacionados a outros valores menores ou maiores que eles
Busca
Carrega o primeiro n√≥ e verifica se o valor est√° antes ou depois do n√≥ (direita ou esquerda) com base no valor se √© maior ou menor, e vai descendo pelos n√≥s da √°rvore
Para cada n√≥ n√£o folha visitado:
Se o n√≥ tem a chave, retorna a chave
Se n√£o, desce para o filho apropriado, baseado no valor da chave se √© menor ou maior que os das chaves do n√≥ atual
Se chegar num n√≥ folha e n√£o for encontrado na posi√ß√£o que deveria estar, retorna NULL.

Algoritmo de Busca em Java
public BNodePosition<T> search(T element) {
	return searchAux(root, element);}
private BNodePosition<T> searchAux(BNode<T> node, T element) {
	int i = 0;
	BNodePosition<T> nodePosition = new BNodePosition<T>();
	while (i <= node.elements.size() && element.compareTo(node.elements.get(i)) > 0) {
		i++;}
	if (i <= node.elements.size() && element.equals(node.elements.get(i))) {
		nodePosition.position = i;
		nodePosition.node = node;
		return nodePosition;}
	if (node.isLeaf()) {
		return new BNodePosition<T>();}
	return searchAux(node.children.get(i), element);
}

Inser√ß√£o
Vai ordenando os valores conforme for inserindo, ou seja, mudando de posi√ß√£o caso entre um valor menor ou valor que o que estava. De forma que a √°rvore fique balanceada e que a p√°gina fique ordenada da menor para a maior chave.
Como √© feita a inser√ß√£o:
Executar algoritmo de busca, que identifica a posi√ß√£o em que a chave dever√° ser inserida. Se a inser√ß√£o for v√°lida, insere a chave no n√≥ adequado.







Algoritmo de Inser√ß√£o em Java


Em caso de p√°gina cheia:
Quando o √∫ltimo campo √© ocupado, faz o split
Divide o n√≥ na metade e pega o √∫ltimo elemento da primeira metade. Sobe ele para um n√≥ acima, criando uma nova raiz
Os elementos que sobraram s√£o redivididos em novos n√≥s abaixo do que subiu
Ex 1: O E subiu e os outros elementos viraram outros n√≥s




Ex 2 :

Ex 3 :

Quando o Split tem que dividir o n√≥ raiz, criando outro nivel ‚Üí Mesma coisa dos outros



















Algoritmo de split


Remo√ß√£o
Duas situa√ß√µes poss√≠veis:
Chave X est√° em um n√≥ folha. Nesse caso, simplesmente retira-se a chave
Se n√£o estiver em um n√≥ folha, pegar a chave imediatamente maior e substituir por ela

No caso de uma remo√ß√£o fazer com que a quantidade de chaves fique menor do que o m√≠nimo poss√≠vel, existem duas solu√ß√µes poss√≠veis:

Concatena√ß√£o: duas p√°ginas podem ser unidas, concatenadas, se elas forem irm√£s adjacentes e se juntas possu√≠rem menos de 2d chaves (n√∫mero m√°ximo de chaves). 
(P√°ginas s√£o irm√£s adjacentes se t√™m o mesmo pai e s√£o apontadas por ponteiros adjacentes desse pai)

Passo a passo:

Seja p√°gina X pai das p√°ginas Y e Z, que s√£o irm√£s adjacentes
Z teve uma chave removida e que ficou com menos de d chaves
Transferir chaves de Z para Y
Transferir a chave de X que separava os ponteiros de Y e Z para Y
Eliminar p√°gina Z e ponteiro 

Redistribui√ß√£o: ocorre quando a soma de chaves de p√°ginas irm√£s adjacentes √© maior que 2d. 

Passo a passo:
Seja p√°gina X pai das p√°ginas Y e Z, que s√£o irm√£s adjacentes
Colocar em Y d chaves
Colocar em X a chave d + 1
Colocar em Z as chaves restantes

Se ambas concatena√ß√£o e redistribui√ß√£o forem poss√≠veis (se possu√≠rem 2 n√≥s adjacentes, cada um levando a uma solu√ß√£o diferente), optar pela redistribui√ß√£o, que √© menos custosa, n√£o se propaga e evita que o n√≥ fique cheio, deixando espa√ßo para futuras inser√ß√µes

Algoritmo de Dele√ß√£o



√Årvore Rubro-Negra
Defini√ß√£o: 

Uma √°rvore rubro-negra √© uma √°rvore bin√°ria de busca auto balanceada, projetada para busca de dados na mem√≥ria principal (RAM), em que cada n√≥ possui os atributos abaixo:

cor (1 bit): pode ser vermelho ou preto. 
key (e.g. inteiro): indica o valor de uma chave.
left, right: ponteiros que apontam para a sub√°rvore esquerda e direita, resp. 
pai: ponteiro que aponta para o n√≥ pai. O campo pai do n√≥ raiz aponta para nil. 

Exemplo:



Uma √°rvore rubro-negra √© uma √°rvore bin√°ria de busca, com algumas propriedades adicionais. Quando um n√≥ n√£o possui um filho (esquerdo ou direito), ent√£o vamos supor que ao inv√©s de apontar para nil, ele aponta para um n√≥ fict√≠cio, que ser√° uma folha da √°rvore. Assim, todos os n√≥s internos cont√™m chaves e todas as folhas s√£o n√≥s fict√≠cios. 
As propriedades da √°rvore rubro-negra s√£o:
Todo n√≥ da √°rvore ou √© vermelho ou √© preto. 
A raiz √© sempre preta;
Toda folha (nil - leaf) √© preta;
Se um n√≥ √© vermelho, ent√£o ambos os filhos s√£o pretos. 
Para todo n√≥, todos os caminhos do n√≥ at√© as folhas descendentes cont√™m o mesmo n√∫mero de n√≥s pretos;
√â uma BST auto balanceada.

Caracter√≠sticas: 
A altura h de uma √°rvore rubro-negra de n chaves ou n√≥s internos √© no m√°ximo 2 log(n + 1).

Complexidade:



Diferen√ßas entre RB e AVL
AVL requer mais rota√ß√µes para ser balanceada;
Rubro negra: m√°ximo de duas rota√ß√µes para cada balanceamento;
A busca √© mais r√°pida em uma AVL, j√° que √© estritamente balanceada;
Inser√ß√£o e dele√ß√£o s√£o mais r√°pidas na rubro negra, j√° que requer menos rota√ß√µes.
Busca
Come√ßando pelo n√≥ raiz da √°rvore, verificar se o valor do n√≥ a ser buscado √© maior ou menor do que o n√≥ atual
Se for menor, o n√≥ atual passa a ser o filho esquerdo do n√≥ antigo (nesse caso, o raiz)
Se for maior, o n√≥ atual passa a ser o filho direito do n√≥ antigo
Realizar esse procedimento at√© encontrar (ou n√£o) o n√≥ desejado
Retornar o valor booleano da busca

C√≥digo:

 private boolean searchNode(RedBlackNode node, int value) {
        boolean check = false;
        while ((node != nullNode) && check != true)
        {
            int nodeValue = node.element;
            if (value < nodeValue)
                node = node.leftChild;
            else if (value > nodeValue)
                node = node.rightChild;
            else
            {
                check = true;
                break;
            }
            check = searchNode(node, value);
        }
        return check;
    }



Inser√ß√£o
Seja x e y n√≥s raiz e folha da √°rvore, respectivamente
Checar se o n√≥ raiz est√° vazio ou n√£o. Se sim, o n√≥ inserido ser√° adicionado como n√≥ raiz de cor preta
Se n√£o, comparar o n√≥ raiz com o novo n√≥. Se o novo n√≥ for maior que a raiz, percorrer pela sub√°rvore direita. Se n√£o, pela esquerda
Repetir passo 3 at√© chegar na folha
Fazer o pai do n√≥ raiz tamb√©m ser pai do novo n√≥
Se o valor do n√≥ folha for menor que o do novo n√≥, novo n√≥ ser√° filho esquerdo. Se for maior, filho direito
Fazer filhos do novo n√≥ como sendo nulos
Novo n√≥ ser√° vermelho
Restaurar as propriedades da √°rvore performando rota√ß√µes ou mudando as cores dos n√≥s.

Algoritmo para manuten√ß√£o das propriedades da √°rvore

Performar os passos at√© que o pai p do n√≥ inserido seja vermelho
Se p for filho esquerdo do n√≥ av√¥ do n√≥ inserido
2.1. Caso 1
Quando a cor do filho direito do n√≥ av√¥ do n√≥ inserido for vermelho, transforme a cor de ambos os filhos do av√¥ para preto e fa√ßa av√¥ ficar vermelho
Designar o n√≥ av√¥ para o n√≥ inserido
2.2. Caso 2
Se n√£o, se o n√≥ inserido for o filho direito do pai, designar p para o n√≥ inserido e realizar rota√ß√£o esquerda
         2.3. Caso 3
Transformar pai para preto e av√¥ para vermelho e performar rota√ß√£o direita para o n√≥ inserido
Se p n√£o for filho esquerdo do n√≥ av√¥
3.1. Se o filho esquerdo do av√¥ for vermelho, transformar ambos os filhos do av√¥ em preto e av√¥ em vermelho
3.2. Designar av√¥ para o n√≥ inserido
3.3. Se n√£o, se o n√≥ inserido for filho esquerdo do pai, designar n√≥ pai para o filho e performar rota√ß√£o direita
3.4. Transformar n√≥ pai para preto e av√¥ para vermelho
3.5. Realizar rota√ß√£o esquerda para n√≥ av√¥
Fazer n√≥ raiz preto

Remo√ß√£o

Algoritmo para remo√ß√£o de n√≥

Realizar a dele√ß√£o padr√£o de √°rvore bin√°ria de busca. Fazendo isso, sempre √© deletado um n√≥ que ou √© folha ou s√≥ tem um filho (se for interno, copia-se o sucessor e recursivamente chama a remo√ß√£o para o sucessor, sendo o sucessor sempre folha ou n√≥ com um filho). Ent√£o s√≥ √© necess√°rio cuidar de casos em que o n√≥ √© folha ou s√≥ tem um filho. Seja v o n√≥ a ser deletado e u o filho que o substitui (u ser√° nulo quando v for folha, e nulo √© sempre preto)
Caso simples - Se ou u ou v s√£o vermelho, deleta-se v e marca-se u como preto
Se ambos u e v forem preto
3.1. Colorir u como double black. Agora deve-se converter double black em apenas black
3.2. Fazer os seguintes passos enquanto u for double black e n√£o for raiz. Seja s o irm√£o de u
	3.2.1 Se s for preto e um de seus filhos for vermelho, realizar rota√ß√£o. Seja r o filho vermelho de s. Existem quatro poss√≠veis alternativas dependendo das posi√ß√µes
Caso esquerda esquerda - s √© filho esquerdo de seu pai e r √© filho direito de s ou ambos os filhos de s s√£o vermelhos. Aqui, o pai p substitui o n√≥ deletado, n√≥ irm√£o s se torna novo pai e o filho esquerdo r substitui s
Caso esquerda direita - s √© filho esquerdo de seu pai e r √© filho direito de s. Nessa situa√ß√£o, filho r substitui s e s se torna filho esquerdo de r. Ap√≥s isso, r se torna pai de p e s.
Caso direita direita - s √© filho direito de seu pai e r √© filho direito de s ou ambos os filhos de s s√£o vermelhos. Nesse caso, o pai p substitui o n√≥ deletado, n√≥ irm√£o s se torna novo pai e o filho direito r substitui s
Caso direita esquerda - s √© filho direito de seu pai e r √© filho esquerdo de s. Nesse caso, filho r substitui s e s se torna filho direito de r. Ap√≥s isso, r se torna pai de p e s.
		3.2.2 Se s for preto e ambos seus filhos s√£o preto, recolorir e                 recorrer ao pai se ele for preto
		3.2.3 Se s for vermelho, performar rota√ß√£o para levantar o antigo irm√£o, recolorir ele e o pai. O novo irm√£o √© sempre preto. Existem duas alternativas para esse caso	
Caso esquerda - s √© filho esquerdo do pai. Rotacionar para direita o pai p
Caso direita - s √© filho direito do pai. Rotacionar para esquerda o pai p
3.3. Se u for raiz, color√≠-lo para apenas black e retornar (altura de pretos da √°rvore reduz em 1).










Quest√µes de √Årvores:


√Årvores B s√£o frequentemente utilizadas para indexa√ß√£o de bancos de dados. Nesse contexto, analise as afirmativas a seguir sobre esse tipo de estrutura de dados. 
I. S√£o balanceadas. 
II. Os n√≥s podem ter mais de dois filhos.
III. A altura da √°rvore √© O(lg(N)). 
Est√° correto o que se afirma em 
A) I, apenas.
B) I e II, apenas.
C) I e III, apenas.
D) II e III, apenas.
E) I, II e III. 
Uma √Årvore-B de ordem m √© uma √°rvore m-direcional tal que todas as folhas est√£o no mesmo n√≠vel. 2. Uma √Årvore-B de ordem m √© uma √°rvore m-direcional tal que todos os n√≥s internos, com exce√ß√£o da raiz, est√£o restritos a terem no m√°ximo 2 filhos n√£o vazios. 3. Uma √Årvore-B de ordem m √© uma √°rvore m-direcional tal que a raiz deve ter pelo menos m filhos n√£o vazios. 
Assinale a alternativa que indica todas as afirmativas corretas.  
Alternativas
A√â correta apenas a afirmativa 1.
B√â correta apenas a afirmativa 2.
CS√£o corretas apenas as afirmativas 1 e 2.
DS√£o corretas apenas as afirmativas 1 e 3.
ES√£o corretas apenas as afirmativas 2 e 3.
Quanto aos conceitos de √°rvore bin√°ria, assinale a alternativa correta. Alternativas
AOpera√ß√µes que utilizam recurs√£o n√£o podem ser realizadas sobre √°rvores bin√°rias.
B A √°rvore pode ser vazia, isto √©, n√£o ter nenhum elemento.
C Uma √°rvore estritamente bin√°ria com n folhas tem 2n2 - 1 n√≥s.
DA altura de um n√≥ √© o comprimento do menor caminho do n√≥ at√© o seu primeiro descendente.

[POSCOMP 2016 ‚Äì FUNDATEC] A opera√ß√£o de destrui√ß√£o de uma √°rvore requer um tipo de percurso em que a libera√ß√£o de um n√≥ √© realizada apenas ap√≥s todos os seus descendentes terem sido tamb√©m liberados. Segundo essa descri√ß√£o, a opera√ß√£o de destrui√ß√£o de uma √°rvore deve ser implementada utilizando o percurso 
A) em ordem. 
B) pr√©-ordem. 
C) central. 
D) sim√©trico. 
E) p√≥s-ordem.  
Resposta:
Considerando que a raiz das √°rvores cont√©m o ponteiro para os dois n√≥s associados (sub-√°rvore da esquerda e sub-√°rvore da direita) ent√£o √© necess√°rio visitar todas sub√°rvores e liberando os n√≥s folha e posteriormente os n√≥s raiz. Ou seja, esse percurso deve deixar a raiz por ultimo, caracterizando o percurso p√≥s-ordem
Resposta correta (E)

 [POSCOMP 2016 ‚Äì FUNDATEC] Uma √°rvore balanceada T que armazena n chaves √© uma √°rvore bin√°ria de pesquisa na qual 
A) A diferen√ßa entre as alturas de suas sub√°rvores permanece constante em todo o caso, ap√≥s inser√ß√µes ou remo√ß√µes de chaves. 
B) As opera√ß√µes de inser√ß√£o e remo√ß√£o de chaves em nodos internos v de T seguem um padr√£o linear de tempo de execu√ß√£o.
C) A propriedade da altura/balanceamento √© determinada pela extens√£o do caminho mais curto entre um nodo interno v at√© o nodo raiz de T. 
D) A varia√ß√£o da altura dos nodos filhos de cada nodo interno v de T √© de, no m√°ximo, uma unidade. 
E) o tempo de execu√ß√£o para todas as opera√ß√µes fundamentais sobre cada nodo interno v de T se mant√©m constante.  
Resposta:
Existem diversos tipos de √°rvores balanceadas (t√©cnicas para manter o balanceamento). Uma √°rvore √© balanceada se a diferen√ßa de altura entre duas sub-√°rvores difere em apenas 1 unidade. 


5) [POSCOMP 2010 ‚Äì COPS ‚Äì UEL] Em uma √Årvore B de ordem, temos que: 
(i) cada n√≥ cont√©m no m√≠nimo m registros (em+1 descendentes) e no m√°ximo 2m registros (e 2m+1 descendentes), exceto o n√≥ raiz que pode conter entre 1 e 2m registros; 
(ii) todas os n√≥s folha aparecem no mesmo n√≠vel.  
Sobre √Årvores B, √© correto afirmar:
a) O particionamento de n√≥s em uma √Årvore B ocorre quando um registro precisa ser inserido em um n√≥com 2m registros.
b) O particionamento de n√≥s em uma √Årvore B ocorre quando um registro precisa ser inserido em um n√≥ commenos de 2m registros.
c) O particionamento de n√≥s em uma √Årvore B ocorre quando a chave do registro a ser inserido cont√©m um valor(conte√∫do) intermedi√°rio entre os valores das chaves dos registros contidos no mesmo n√≥.
d) O particionamento de n√≥s ocorre quando √© necess√°rio diminuir a altura da √°rvore.
e) Em uma √Årvore B, aumenta em um n√≠vel sua altura, toda vez que ocorre o particionamento de um n√≥. 
Resposta:
Resposta correta (A) 


6) [POSCOMP 2009] Quais das seguintes propriedades n√£o se aplicam a √°rvores rubro-negras?
A) Todo n√≥ √© vermelho ou preto.
B) Todo n√≥ folha √© preto.
C) Se um n√≥ √© preto, ambos seus filhos s√£o vermelhos.
D) Se um n√≥ √© vermelho, ambos seus filhos s√£o negros.
E) Todos os caminhos simples entre um n√≥ e suas folhas descendentes cont√™m omesmo n√∫mero de n√≥s pretos. 
Resposta:
Resposta correta (E)



7) Em uma √°rvore bin√°ria de busca balanceada do tipo AVL, as alturas das duas sub-√°rvores de um n√≥ qualquer diferem em no m√°ximo 1. A constru√ß√£o de uma √°rvore desse tipo, inicialmente vazia, por meio da inser√ß√£o sucessiva de n√≥s, utiliza uma certa opera√ß√£o para manter o balanceamento desejado quando necess√°rio. Essa opera√ß√£o √© 
A) empilhamento.

B) desempilhamento.

C) concatena√ß√£o.

D) rota√ß√£o.

E) poda.
Resposta:
Resposta correta (D)





























